#' GRAFit: Setup the Data/Model
#'
#' @description This function sets up the profit.class data and the initial model required for optimization.
#' @param output_dir The directory to save outputs including the plots of the final model and standard \code{ProFit} plots.
#' @param main_src A list containing the specification of the main source in the cutout. This should be generated by the \code{ProFound}.
#' @param nComp Number of components to be used in fitting. Default = 2 for a bulge+disk model. Alternatively could be 1 for a single Sersic model.
#' @param ExpDisk A logical value. Should the disk be fitted with a pure exponential profile (\code{Sersic index = 1}). Default = \code{FALSE}; for a free Sersic profile.
#' @param FreeBulge Logical; Should the bulge location (\code{x \& y}) also be fitted by GRAFit. Default = \code{FALSE}, i.e. the bulge position will be fixed to the disk position.
#' @param BulgeFreeness In unit pixels. How many pixels the bulge position is allowed to be free from the centre of disk. Default = 11.
#' @param BT_flux_ratio The Bulge/Total flux ratio to estimate the initial bulge flux/magnitude from the total magnitude.
#' @param ZP Numeric scalar; the magnitude zero point.
#' @param image Image matrix; required, the galaxy image we want to fit a model to. The galaxy should be approximately central within this image.
#' @param mask Logical matrix; optional, non galaxy parts of the image to mask out, where 1 means mask out and 0 means use for analysis. If region is not provided then 0 values are used to define the common area to use for fitting. This matrix *must* be the same dimensions as image.
#' @param sigma Sigma matrix; optional, the measurement errors per pixel (expressed in terms of sigma). This matrix *must* be the same dimensions as image
#' @param pix_scale Pixel scale in units of arcsecond/pixel.
#' @param segim Segmentation matrix; optional, the full segmentation map of the image. If region is not provided then value of the central pixel is used to select the segmented pixels of the galaxy we want to fit. The log-likelihood is then computed using only these pixels. This matrix *must* be the same dimensions as image.
#' @param psf Matrix; optional. An empirical point spread function (PSF) image matrix that ProFit will use to convolve the image, as an alternative to defining an analytical PSF in modellist. This should have odd sizes in each dimension. If the dimension has an even size then the function will internally interpolate it onto an odd sized grid 1 element larger. \code{\link[ProFit]{profitSetupData}} forces negative values to equal 0. During any convolution \code{\link[ProFit]{profitConvolvePSF}} will force the sum of the pixels to equal 1 to ensure flux conservation during convolution of the model image.
#' @param SBlim 5 sigma surface brightness limit of the data typically in units of mag/asec^2. Default = 26.
#' @param like.func likelihhod function to be parsed to the ProFit: "t": t-distribution, "norm": normal distribution. See ProFit package for more details.
#' @param DoPriors Logical; Should a prior distribution be applied to the fitting process. Default = \code{TRUE}.
#' @param DoConstraits Logical; Should constraints be applied to the fitting process. Default = \code{TRUE}.
#' @return Plots of the initial model as well as the Data as a list.
#' @author Hosein Hashemizadeh
#' @seealso \code{\link[GRAFit]{GRAFitDynamo_v2}}
#' @examples -
#' @export


GRAFitInitModelSetupConst <- function( output_dir = NULL, GRAFitlib = GRAFitlib, main_src = NULL, nComp = 2,
                                  ExpDisk = FALSE, FreeBulge = FALSE, BulgeFreeness = 11, BT_flux_ratio = 0.2,
                                  ZP = NULL, image = image, mask = mask, sigma = sigma, pix_scale = pix_scale,
                                  segim = segim, psf = psf, SBlim = SBlim, like.func = "t",
                                  DoPriors = TRUE, DoConstraits = TRUE )  {

  source(paste(GRAFitlib,'/GRAFitAddFakeBulge.R', sep=''))
  source(paste(GRAFitlib,'/GRAFitEllipsePlot.R',sep=''))

  if (missing(output_dir)) output_dir = getwd()

  if (nComp == 2) {
    ang <- c(0,main_src$ang)
    xcen <- main_src$xcen
    ycen <- main_src$ycen
    mag <- -2.5 * log10( c( main_src$flux * BT_flux_ratio, main_src$flux * (1 - BT_flux_ratio) ) ) + ZP
    re = main_src$R50/pix_scale
    axrat <- c( 1, ( main_src$axrat ) )

    modellist = list(
      sersic = list(
        xcen = rep(xcen,2),
        ycen = rep(ycen,2),
        mag = mag ,
        re = c(0.2*re,re),
        nser = c(4., 1.),
        ang = ang,
        axrat = axrat, #min/maj: 1= o, 0= |
        box = c(0., 0.)
      )
    )

    if (ExpDisk) {
      if (FreeBulge) {
        tofit = list(
          sersic = list(
            xcen = c(TRUE,TRUE),   # Fit for both
            ycen = c(TRUE,TRUE),   # Fit for both
            mag = c(TRUE,TRUE),    # Fit for both
            re = c(TRUE,TRUE),     # Fit for both
            nser = c(TRUE,FALSE),  # Fit for bulge only
            ang = c(FALSE,TRUE),   # Fit for disk
            axrat = c(FALSE,TRUE), # Fit for disk
            box = c(FALSE,FALSE)   # Fit for neither
          )
        )
      } else {
        tofit = list(
          sersic = list(
            xcen = c(TRUE,NA),   # Fit for xcen of bulge and use it for disk as well.
            ycen = c(TRUE,NA),   # Fit for ycen of bulge and use it for disk as well.
            mag = c(TRUE,TRUE),  # Fit for both
            re = c(TRUE,TRUE),   # Fit for both
            nser = c(TRUE,FALSE), # Fit for bulge only
            ang = c(FALSE,TRUE), # Fit for disk
            axrat = c(FALSE,TRUE), # Fit for disk
            box = c(FALSE,FALSE) # Fit for neither
          )
        )
      }

    } else {
      if (FreeBulge) {
        tofit = list(
          sersic = list(
            xcen = c(TRUE,TRUE),   # Fit for both
            ycen = c(TRUE,TRUE),   # Fit for both
            mag = c(TRUE,TRUE),    # Fit for both
            re = c(TRUE,TRUE),     # Fit for both
            nser = c(TRUE,TRUE),   # Fit for both
            ang = c(FALSE,TRUE),   # Fit for disk
            axrat = c(FALSE,TRUE), # Fit for disk
            box = c(FALSE,FALSE)   # Fit for neither
          )
        )
      } else {
        tofit = list(
          sersic = list(
            xcen = c(TRUE,NA),     # Keep the centre of disk and bulge on top of each other.
            ycen = c(TRUE,NA),     # Keep the centre of disk and bulge on top of each other.
            mag = c(TRUE,TRUE),    # Fit for both
            re = c(TRUE,TRUE),     # Fit for both
            nser = c(TRUE,TRUE),   # Fit for both
            ang = c(FALSE,TRUE),   # Fit for disk
            axrat = c(FALSE,TRUE), # Fit for disk
            box = c(FALSE,FALSE)   # Fit for neither
          )
        )
      }

    }

    # What parameters should be fitted in log space:

    tolog = list(
      sersic = list(
        xcen = c(FALSE,FALSE),
        ycen = c(FALSE,FALSE),
        mag = c(FALSE,FALSE),
        re = c(TRUE,TRUE),    #re is best fit in log space
        nser = c(TRUE,TRUE),  #nser is best fit in log space
        ang = c(FALSE,FALSE),
        axrat = c(TRUE,TRUE), #axrat is best fit in log space
        box = c(FALSE,FALSE)
      )
    )

    if (DoPriors) {
      sigmas = c(2,2,5,0.3,0.1,30,0.3,Inf) # xcen, ycen, mag, Re, nser, ang, axrat, box

      sigmas = list(
        sersic = list(
          xcen = numeric(2) + sigmas[1],
          ycen = numeric(2) + sigmas[2],
          mag = numeric(2) + sigmas[3],
          re = numeric(2) + sigmas[4],
          nser = c(sigmas[4], sigmas[5]),
          ang = numeric(2) + sigmas[6],
          axrat = numeric(2) + sigmas[7],
          box = numeric(2) + sigmas[8]
        )
      )

      priors = profitMakePriors(modellist = modellist, sigmas = sigmas,
                                tolog = tolog, tofit = tofit, allowflat = TRUE)
    }

    intervals = list(
      sersic = list(
        # xcen = list(lim = c(xcen - 20.0, xcen + 20.0), lim = c(xcen - 10.0, xcen + 10.0)),
        # ycen = list(lim = c(ycen - 20.0, ycen + 20.0), lim = c(ycen - 10.0, ycen + 10.0)),
        xcen  = list( lim = c(-Inf, Inf), lim = c(xcen - 10.0, xcen + 10.0) ),
        ycen  = list( lim = c(-Inf, Inf), lim = c(ycen - 10.0, ycen + 10.0) ),
        mag   = list( lim = c(10.0,40.0), lim = c(10.0,40.0) ),
        re    = list( lim = c(0.001, dim(image)[1]), lim = c(0.001, dim(image)[1]) ),
        nser  = list( lim = c(0.5,20.0), lim = c(0.5,1.5) ),
        ang   = list( lim = c(-180.,360.), lim = c(-180.,360.) ),
        axrat = list( lim = c(0.1,1.0), lim = c(0.1,1.0) ),
        box   = list( lim = c(-1.0,1.0), lim = c(-1.0,1.0) )
      )
    )

    # constraints -------------------------------------
    #         constraints=function(modellist){
    #           if(modellist$sersic$re[1]>modellist$sersic$re[2]){
    #             modellist$sersic$re[1]=modellist$sersic$re[2]
    #           }
    #           return=modellist
    #         }
    # constraints -------------------------------------
    # freeness = BulgeFreeness -1
    # freeness = freeness / 2

    if (DoConstraits) {
      constraints = function( modellist ){
        r = sqrt( (modellist$sersic$xcen[1] - modellist$sersic$xcen[2]) ** 2 +
                    (modellist$sersic$ycen[1] - modellist$sersic$ycen[2]) ** 2 )

        if( r >  BulgeFreeness ){
          modellist$sersic$xcen[1] = modellist$sersic$xcen[2] + (BulgeFreeness/r)*(modellist$sersic$xcen[1] - modellist$sersic$xcen[2])
          modellist$sersic$ycen[1] = modellist$sersic$ycen[2] + (BulgeFreeness/r)*(modellist$sersic$ycen[1] - modellist$sersic$ycen[2])

        }
        return = modellist
      }
    }

    #tempCL=profitOpenCLEnv()
    if (DoPriors & DoConstraits) {
      Data <- profitSetupData(image = image, mask = mask, sigma = sigma, segim = segim,
                              psf = psf, modellist = modellist, tofit = tofit, tolog = tolog,
                              priors = priors, intervals = intervals, constraints = constraints, magzero = ZP,
                              algo.func = 'optim', verbose = FALSE, like.func = like.func)
    } else if (DoPriors & !DoConstraits) {
      Data <- profitSetupData(image = image, mask = mask, sigma = sigma, segim = segim,
                              psf = psf, modellist = modellist, tofit = tofit, tolog = tolog,
                              priors = priors, intervals = intervals, magzero = ZP,
                              algo.func = 'optim', verbose = FALSE, like.func = like.func)
    } else if (!DoPriors & DoConstraits) {
      Data <- profitSetupData(image = image, mask = mask, sigma = sigma, segim = segim,
                              psf = psf, modellist = modellist, tofit = tofit, tolog = tolog,
                              intervals = intervals, constraints = constraints, magzero = ZP,
                              algo.func = 'optim', verbose = FALSE, like.func = like.func)
    } else {
      Data <- profitSetupData(image = image, mask = mask, sigma = sigma, segim = segim,
                              psf = psf, modellist = modellist, tofit = tofit, tolog = tolog,
                              intervals = intervals, magzero = ZP,
                              algo.func = 'optim', verbose = FALSE, like.func = like.func)
    }

    ##########################
    ###### Initial Model #####
    ##########################

    png(file = paste(output_dir, 'initial_model.png', sep = "/"), width = 8, height = 2.5, units = "in", res = 200)
      profitLikeModel(parm = Data$init, Data = Data, makeplots = TRUE, whichcomponents = list(sersic = "all"))
    dev.off()

    png(file = paste(output_dir,'initial_1D_profile.png',sep = "/"), width = 10, height = 7, units = "in", res = 200)
      SBprof = GRAFitEllipsePlot(Data = Data, modellist = Data$modellist,
                                 pixscale = pix_scale, FWHM = 0.09, SBlim = SBlim,
                                 GRAFitlib = GRAFitlib)
    dev.off()


  } else if (nComp == 1) {
    ang  <- main_src$ang
    xcen <- main_src$xcen
    ycen <- main_src$ycen
    # mag <- -2.5*log10(c(main_src$flux*0.1,main_src$flux*0.9))-48.6
    # mag <- main_src$mag
    # flux <- main_src$flux
    mag  <- -2.5*log10(main_src$flux) + ZP
    re=sqrt(main_src$N50/(pi*main_src$axrat))  # = R50/pix_scale
    axrat <- main_src$axrat

    modellist = list(
      sersic = list(
        xcen = xcen,
        ycen = ycen,
        mag = mag ,
        re = re,
        nser = 1/main_src$con,
        ang = ang,
        axrat = axrat, #min/maj: 1= o, 0= |
        box = 0
      )
    )

    tofit = list(
      sersic = list(
        xcen = TRUE, # fit for xcen of the single component.
        ycen = TRUE, # fit for ycen of the single component.
        mag = TRUE, # Fit for both
        re = TRUE, # Fit for both
        nser = TRUE, # Fit for bulge
        ang = TRUE, # Fit for disk
        axrat = TRUE, # Fit for disk
        box = FALSE # Fit for neither
      )
    )

    # What parameters should be fitted in log space:

    tolog = list(
      sersic = list(
        xcen = FALSE,
        ycen = FALSE,
        mag = FALSE,
        re = TRUE,    #re is best fit in log space
        nser = TRUE,  #nser is best fit in log space
        ang = FALSE,
        axrat = TRUE, #axrat is best fit in log space
        box = FALSE
      )
    )

    if (DoPriors) {
      sigmas = c(2,2,5,0.3,0.3,30,0.3,Inf)

      sigmas = list(
        sersic = list(
          xcen = sigmas[1],
          ycen = sigmas[2],
          mag = sigmas[3],
          re = sigmas[4],
          nser = sigmas[5],
          ang = sigmas[6],
          axrat = sigmas[7],
          box = sigmas[8]
        )
      )

      priors = profitMakePriors(modellist, sigmas, tolog, allowflat = TRUE)

    }

    # The hard intervals should also be specified in log space if relevant:

    intervals = list(
      sersic = list(
        xcen = list(lim = c(xcen-10, xcen+10)),
        ycen = list(lim = c(ycen-10, ycen+10)),
        mag = list(lim = c(10., 40.)),
        re = list(lim = c(1.0,dim(image)[1])),
        nser = list(lim = c(0.5, 15)),
        ang = list(lim = c(-180., 360.)),
        axrat = list(lim = c(0.1, 1.)),
        box = list(lim = c(-1, 1.))
      )
    )

    #tempCL=profitOpenCLEnv()
    if (DoPriors) {
      Data <- profitSetupData(image = image, mask = mask, sigma = sigma, segim = segim,
                              psf = psf, modellist = modellist, tofit = tofit, tolog = tolog,
                              priors = priors, intervals = intervals, magzero = ZP,
                              algo.func = 'optim', verbose = FALSE, like.func = like.func)
    } else {
      Data <- profitSetupData(image = image, mask = mask, sigma = sigma, segim = segim,
                              psf = psf, modellist = modellist, tofit = tofit, tolog = tolog,
                              intervals = intervals, magzero = ZP,
                              algo.func = 'optim', verbose = FALSE, like.func = like.func)
    }

    ##########################
    ###### Initial Model #####
    ##########################
    png(file = paste(output_dir, 'initial_model.png', sep = "/"), width = 8, height = 2.5, units = "in", res = 200)
    # CairoPNG(file = paste(output_dir, 'initial_model.png', sep = "/"), width = 1450, height = 400)
      profitLikeModel(parm = Data$init, Data = Data, makeplots = TRUE, whichcomponents = list(sersic = 1))
    dev.off()

    # CairoPNG(file = paste(output_dir, 'initial_1D_profile.png', sep = "/"), width = 800, height = 500, pointsize = 15)
    png(file = paste(output_dir,'initial_1D_profile0.png',sep = "/"),width=7,height=5,units="in", res = 200)
      SBprof = GRAFitEllipsePlot(Data = Data, modellist = GRAFitAddFakeBulge(model =  Data$modellist, zeropoint = ZP),
                               pixscale = pix_scale, FWHM = 0.09, SBlim = SBlim,
                               GRAFitlib = GRAFitlib)
    dev.off()
  } # end of if on fit components.

  return(list(Data = Data, SBprof = SBprof))

}

# END



